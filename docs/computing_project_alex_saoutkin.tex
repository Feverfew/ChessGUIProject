\documentclass[twoside, 12pt]{report}
\usepackage{float}
\usepackage{minted}
% Margin settings
\usepackage[a4paper, portrait, margin=1in]{geometry}
%Table of Contents settings
\usepackage{hyperref}
\hypersetup{linktoc=all}
% Chapter settings
\usepackage{titlesec}
\titleformat{\chapter}[display]{\normalfont\Large\bfseries}{}{0.5ex}{}{}
% Paragraph settings
\setlength{\parskip}{1em}
\setlength{\parindent}{0pt}
\linespread{1.6} % Double line-spacing
% Images
\usepackage{graphicx}
\usepackage{tikz}
\newcommand*\annotatedFigureBoxCustom[8]{\draw[#5,thick,rounded corners] (#1) rectangle (#2);\node at (#4) [fill=#6,thick,shape=circle,draw=#7,inner sep=2pt,font=\sffamily,text=#8] {\textbf{#3}};}
%\annotatedFigureBox{bottom-left}{top-right}{label}{label-position}
\newcommand*\annotatedFigureBox[4]{\annotatedFigureBoxCustom{#1}{#2}{#3}{#4}{black}{white}{black}{black}}
\newcommand*\annotatedFigureText[4]{\node[draw=none, anchor=south west, text=#2, inner sep=0, text width=#3\linewidth,font=\sffamily] at (#1){#4};}
\newenvironment {annotatedFigure}[1]{\centering\begin{tikzpicture}
	\node[anchor=south west,inner sep=0] (image) at (0,0) { #1};\begin{scope}[x={(image.south east)},y={(image.north west)}]}{\end{scope}\end{tikzpicture}}

% Directory Tree
\usepackage{dirtree}
% Lists
\usepackage{enumitem}
% Header & Footer Style
\usepackage{fancyhdr}
\pagestyle{fancy}
% \renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\chaptermark}[1]{%
	\markboth{\thechapter.\ #1}{}}

\fancyhf{}
\fancyhead[LE, RO]{\nouppercase{\textsl{\leftmark}}}
\fancyhead[CE, CO]{Alexander Saoutkin}
\fancyhead[RE, LO]{Candidate Number: 0191}
\fancyfoot[LE, RO]{\thepage}


% Title Page
\title{Chess for students; written in Python}
\author{Alexander Saoutkin}


\begin{document}
\pagenumbering{roman}
\maketitle
\tableofcontents
\newpage
\chapter{Analysis}
\pagenumbering{arabic}
\section{Introduction}
The goal of this project was to build a desktop application which can be used to play chess amongst 2 human players. It will be used by those who attend chess club to not only play games but to save, load and continue playing them. This program is to be developed in Python and for the graphical user interface Qt has been chosen, with the Pyside library serving as a python wrapper around the Qt GUI framework. 

It consists of a visual representation of a chess board which is held in a table GUI element. This allows players to move pieces via clicking on a piece and then on the place it wants to move the piece to. It contains several buttons, which all complete several different functions. There is functionality to start a new game and to save, and load, existing games. Saving a game works by converting a python dictionary into JSON format and saving it in an existing JSON file by adding it to an array of dictionaries (games). If this file does not exist then the program allows the user to select a location for a new JSON file to be created, this location is saved as a setting so that the program can find this location again whenever it is relaunched.
 
Loading a game opens the JSON file from the location path that is saved as a setting and scans the array of games, showing them as a table in a dialog, so that the user can choose which game to open. If the location of the file does not exist, then the user is given the option of locating a different pre-existing JSON file to open from if it exists.

As already mentioned, the JSON file holds an array of games. A game contains the data needed to load a game: pieces and their positions, total moves, state of the game and other variables that are used to determine whether certain moves are possible, such as castling. Each game has a unique ID which allows users to load game that haven't been finished and to carry them on. For the program's loading and saving feature to be most useful for the school's chess club, it is best to store the JSON file in the school's shared area such that all games can be loaded and saved from any computer that has this program installed.

\section{Rules of Chess}
As with any game, there are rules that have to be adhered to for a valid game to be played. For me to have a viable solution to the problem identified, the program I create must follow the rules of chess. Thus in this section I will discuss what these rules are.
\subsection{The Game Board}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/initial_board}
	\caption{The initial setup of a game of chess.}
	\label{initial-board}
\end{figure}
The initial starting position of the board contains all the types of pieces in the game: pawn, king, queen, bishop, knight and rook. From this point onwards, white is the first to move. Once white has completed a legal move it is then black's turn to do the same and the game continues until the game has reached the state of checkmate and stalemate, which will be explained in detail later. Only one piece can occupy a square on the board, thus a piece cannot take one of its own pieces but can capture opposing pieces as long as it isn't a king.

\paragraph{Note:}when the types of moves that a certain type of piece can make are discussed below, it is assumed that when moved, it does not put the player who is moving the piece into check. In addition, it will be assumed that the move does not mean that the moving piece is in the same place. If this is the case then the move is illegal.
\subsection{Pawns}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/pawn_movement}
	\caption{The possible moves a pawn can make.}
\end{figure}
The pawn is a type of piece and has two types of moves, depending on the situation. If the pawn is in the same space as its starting position then it can either move one or two spaces forward, given that there is no piece in the way of this movement. In any other position it is only able to move into the next square forward, as long as there is no other piece currently there. 
\subsubsection{Promotion}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/promotion}
	\caption{The types of pieces that a pawn can be promoted to.}
\end{figure}
When a pawn reaches the other side of the board the pawn must be changed to an additional piece that is a rook, knight, bishop or queen.
\subsubsection{En Passant}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/en_passant}
	\caption{A board position in which en passant is possible.}
\end{figure}
As can be seen above, if a pawn is moved two spaces forward such that it is horizontally adjacent to an opposing pawn once it is moved, the opposing pawn has an opportunity to capture the pawn and move to the â€˜x' marked on the diagram. When this opportunity occurs, whether it is taken or not, it cannot be done again by that player for the rest of the game.
\subsection{Kings}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/king_movement}
	\caption{The possible moves of a king.}
\end{figure}
The king can move to any adjacent square provided that it is not in check once it completes the move. In addition it should not be adjacent diagonally, horizontally or vertically, to the opposing king after it has moved. 
\subsubsection{Castling}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/castling}
	\caption{Movement of king and rook during castling.}
\end{figure}
Castling is a move (shown above) that can be performed only if the king and rook have not been moved before. For castling to be performed no pieces must be in the way of the king and the rook moving and any of the squares in between them must not be attacked by an opposing piece.
\subsection{Bishop}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/bishop_movement}
	\caption{The possible moves of a bishop.}
\end{figure}
The bishop can move diagonally in any direction. Thus, it can only move on the colour of squares that are the same as its starting position.	
\subsection{Rook}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/rook_movement}
	\caption{The possibles moves of a rook.}
\end{figure}
The rook can move both vertically and horizontally in any direction.
\subsection{Queen}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/queen_movement}
	\caption{The possible moves of a queen.}
\end{figure}
The queen can both move anywhere diagonally, horizontally and vertically. In other words, a queen can be considered a combination of both the rook and the bishop.
\subsection{Knight}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/knight_movement}
	\caption{The possible moves of a knight.}
\end{figure}
The knight has one of the more interesting moving patterns. It can move in what is known as an L-shape. To be more precise, the possible moves of a knight can be calculated by moving 2 along vertically and then 1 horizontally either side, and vice-versa. Its attacking moves do not include the path to its possible moves.
\subsection{Game States}
In chess there are 3 types of game states that differ from normal play and restrict what legal moves can be made. Two of those are permanent (end of game) states: checkmate and stalemate. The other is check and this means that only moves that take a player out of check can be made. 
\subsubsection{Check}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/check_example}
	\caption{An example of check.}
\end{figure}
Check occurs when a piece moves such that it is attacking the opposing king. An attacking move is such that if we theoretically suppose that the king is a piece that can be captured by a piece, then it would be captured if the piece moved there. An example of this is the image seen above. An important note is that for pawns this means they cannot check a king if it is horizontally ahead of it, as a pawn cannot move there if we theoretically supposed that a king is able to be captured. However, it can if the king is diagonally adjacent in front of the pawn. 
\subsubsection{Checkmate}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/checkmate_example}
	\caption{An example of checkmate.}
\end{figure}
Checkmate occurs when a player is put into check and cannot make a move that brings themselves out of check. The person who is in check is the loser of the game and thus the opposing player is the winner. A well-known example is the scholar's mate which can be seen above. The queen cannot be taken by any piece and the king has nowhere to move without still being in check. In addition, the king cannot take the queen as it will put itself in check to the bishop. Thus black concedes the game as it is in a state of checkmate.
\subsubsection{Stalemate}
\begin{figure}[H]
\centering
	\includegraphics[width=0.3\textwidth]{images/boards/stalemate_example}
	\caption{An example of stalemate.}
\end{figure}
Stalemate occurs when a player who is not in check cannot make any legal moves and thus the game cannot continue. Above is an example of a stalemate. It is black's turn to move but it has no legal moves to make. Any movements are either not available to make or expose the king to being in check to either the far-right pawn or the queen. When a stalemate occurs the game is declared as drawn and there are no winners or losers.
\section{Setting}
The program was designed for the school's Chess club and is open for students from year 7 to 13. Chess club currently runs weekly at lunchtimes and is run by a physics teacher â€“ Dr De Silva. Every year a primarily student run inter-house chess competition, with each house having a team of avid chess players, takes place to determine which house has the best chess players. As a member of chess club I identified and researched problems with the current system that the club uses. I also consulted with Dr De Silva about any problems that he has noted in the current system and have used this information to aid me in determining the objectives that I plan for the new system to implement.
\section{Users}
The primary users are those students who partake in the chess club and actively play chess amongst one another. It can also be used by the teacher that runs the club to record the results of games, which is paramount when there are competitions taking place. There is an additional benefit in that it can be played at any time and on any computer in the school area that has the program installed. This may be of good use to those who would like to play chess but are unable to go to the club due to other extra-curricular activities.
\section{System}
Currently most games that are played are not recorded because most are for recreational entertainment and so the result of the game is inconsequential, though results may be remembered by students and also may help in choosing players for the inter-house chess competition. Currently, when the inter-house chess competition happens the whiteboard in the classroom is used to show players who they are playing against and when the game is finished the result is written to the right of the matchings. Then the results are transferred to paper and are stored by the teacher who runs the club.
\section{Input}
All the results of games to do with a competition are recorded in a notebook and of course the movement of pieces is recorded on the board. All other games are not recorded at all and the location of pieces when a game is finished are generally not stored unless a student chooses to take a picture of the board.
\section{Processing}
Processing in the current system is fairly simple. Once a player has chosen where to move a piece, they pick it up and move it to the appropriate position on the board. If it is illegal it is assumed that the opponent will notice as it is in their best interest to not allow such a move. If that is the case then the piece is simply moved back to its place. The player who moves a piece also notes mentally if the piece that they have moved has resulted in a change in the state of the game.
\section{Output}
Output is simply where the player moves their piece on the board, which is visible to both players and any people watching. In addition, when a player moves a piece which results in the changing of the game state they must state this change openly to the opposing player.
\section{Volumetrics}
In this particular application it is hard to estimate the memory needed to store the data needed to play a game as the data required is dynamic. However, we can make some assumptions about the game and use this to estimate the memory required. 

Firstly, I'll discuss the byte allocations that the Python programming language gives to certain objects and data structures:
\begin{table}[H]
\centering
	\begin{tabular}{| l | l | l |}
		\hline
		\textbf{Bytes} & \textbf{Type} & \textbf{Details} \\ \hline
		24 & int & \\ \hline
		24 & bool & an instance of an int\\ \hline
		52 & str (unicode) & +4 byte per additional character. \\ \hline
		72 & list & +32 for first element, 8 thereafter. \\ \hline
		280 & dict & 6th item increases to 1048; 22nd, 3352; 86th, 12568 * \\ \hline
	\end{tabular}
	\caption{Byte allocations for primitive data types in Python.}
\end{table}
Firstly, the game is stored in a 2D $ (8\times8) $ list object, with each element of the list containing either an integer with value 0 or a Piece object. However, this is not how the data is stored in the JSON file. Instead, the JSON file mimics all the attributes of the \mintinline{python}/class Board(object)/, apart from the \mintinline{python}/board/ attribute.

In the following table, a list of all the attributes of the board class are contained with the type that they will be stored as in the JSON file. This table will show how many bytes are required to store a game as an upper bound. It is assumed that the player names are 10 characters long, which is unlikely to be the case for one player, let alone two. In addition, it is assumed that no pieces are taken, as if that is the case, then the size of the file will inevitably be smaller.

\begin{table}[H]
	\resizebox{\textwidth}{!}{%
	\begin{tabular}{| l | l | l | l |}
		\hline
		\textbf{Attribute} & \textbf{Type} & \textbf{Bytes} & \textbf{Occurence}\\ \hline
		id & int & 24 & 1\\ \hline
		player{\_}one & str  & $ 52+4\times8=84 $ (assuming 10 characters).& 1\\ \hline
		player{\_}two & str  & $ 52+4\times8=84 $ (assuming 10 characters).& 1\\ \hline
		last{\_}played & str & $ 52+4\times10=92 $ (in format dd/mm/yyyy) & 1\\ \hline
		turn & str & $ 52+4\times5=72 $ ("White" or "Black")& 1\\ \hline
		move{\_}num & int & 24 & 1\\ \hline
		winner & str & $ 52+4\times5=72 $ ("White" or "Black")& 1\\ \hline
		colour{\_}in{\_}check & str & $ 52+4\times5=72 $ ("White" or "Black")& 1\\ \hline
		is{\_}stalemate & bool(int) & 24 & 1\\ \hline
		game{\_}over & bool(int) & 24 & 1\\ \hline
		must{\_}promote & bool(int) & 24 & 1\\ \hline
		enpassant{\_}possible & dict & 280 & 1\\ \hline
		enpassant{\_}possible['Black'] & bool(int) & 24 & 1\\ \hline
		enpassant{\_}possible['White'] & bool(int) & 24 & 1\\ \hline
		enpassant{\_}move & dict & 280 & 1\\ \hline
		enpassant{\_}move['from'] & list & $ 72+32+24+8+2=150 $ & 1\\ \hline
		enpassant{\_}move['to'] & list & $ 72+32+24+8+24=150 $ & 1\\ \hline
		enpassant{\_}move['taken'] & list & $ 72+32+24+8+24=150 $ & 1\\ \hline
		pieces & dict & 280 & 1\\ \hline
		pieces[*] & dict & 280 & 5\\ \hline
		pieces[*]['position'] & list & $ 72+32+24+8+24=150 $ & 32 (all pieces)\\ \hline
		pieces[*]['colour'] & str & $ 52+4\times5=72 $ ("White" or "Black")& 32 (all pieces)\\ \hline
		pieces[*]['first{\_}moved'] & int & 24 & 16 (all pawns)\\ \hline
		pieces[*]['has{\_}moved'] & list & $ 72+32+24+8+24=150 $ & 6 (rooks and kings)\\ \hline
		\multicolumn{2}{|r|}{\textbf{Total}} & \multicolumn{2}{|l|}{11,722 bytes} \\ \hline
	\end{tabular}}
	\caption{Bytes required for the storing of one chess game.}
\end{table}
Whilst the following table helps to calculate the size of storing each game, it is not taken into account the overhead of the game list. Thus the formula, $ f(x) $, where $ x $ is the number of games stored, for the upper bound in bytes of the JSON file is:\[ f(x) = (11722)x + (72+32) + 8(x-1) = 11730x + 96\]
\section{Problems with the Current System}
The current system consists of chess boards with pieces and paper if results want to be recorded. The main problem that was noticed was that as the club was only hosted on a single lunchtime a week, many games overran past lunchtime and so had to be stopped with no clear winner as the game had not finished. As the game was played on a physical board with pieces and the room that was used for the club is used for lessons as well, the current state of the game is not saved which resulted in the game effectively being cut short. This is incredibly frustrating, especially for higher-level players as their games tend to take longer to finish. 

Another problem came from when in-school chess competitions occurred. These competitions required results to be recorded such that it could be determined who plays who in further rounds of the competition, i.e. what teams play against one another in the final. These are recorded at lunchtime on the board and then recorded later on paper. There are of course problems with such a system. Firstly, results can easily be lost as it is held in one location. This also means that only one person can view the results at the time, unless the results are published in an e-mail which takes time to produce. In addition, it does not store the final state of the game when finished which may be of interest to students and teachers alike.

A problem that has been noted by students is that even though they are willing to attend chess club, many are unable to attend at lunchtimes on a certain day because they have other commitments and so end up not attending at all despite their desire to do so. Many students would like to be able to play chess games outside of club hours amongst each other with results recorded at school.
\section{Objectives}
After the analysis of the current system and the requirements that would be needed for an improved system I have created SMART (Specific, Measurable, Achievable, Realistic and Timely) objectives which make clear to me - the developer â€“ what the client requires for their new system which has been determined to be accomplishable and adheres to all of the letters of the SMART abbreviation: Specific, Measurable, Achievable, Realistic, Timely.

The objectives of the new system are as follows:
\begin{enumerate}
	\item The showing of an interactive chess board allowing movement of pieces by users which adheres to all chess rules.
	\begin{enumerate}
		\item When program loads, show default chess starting position (a new game).
		\item Ensure only pieces of the moving player's corresponding colour are clickable.
		\item When a piece is clicked calculate all of its legal moves.
		\begin{enumerate}
			\item For each type of piece calculate where it could possibly go assuming there are no other pieces on the board (i.e. bishops diagonally, rooks horizontally/vertically etc.).
			\item Taking into account where other pieces are on the board, calculate the possible moves for that piece.
			\item Considering the moves that have been calculated, check that each position does not result in the moving player to be in check. 
			\begin{enumerate}
				\item If a move results in a player going into check then remove that move from the list of legal moves.
			\end{enumerate}
			\item When this calculation is done, cells in the table corresponding to the legal moves must be made clickable so that the player can move the appropriate piece there if they wish.
			
		\end{enumerate}
		\item After a piece is moved perform a check of the game state. If the state has changed (i.e. if a player has been put into check or the game has ended) then inform the user of this via a dialog.
		\item If the pawn has successfully reached the other side of the board, then open a dialog to let the user decide to what piece the pawn should be converted to.
	\end{enumerate}
	\item Allow the editing of player's names via textboxes.
	\item Allow a game that is currently in play to be saved.
	\begin{enumerate}
		\item If there is no file path to save the game to, prompt the user for a path and filename to save a new JSON file to.
		\item If there is a file path and the JSON file is found, then save the game to the file.
		\item If there is a file path and the JSON isn't found, then prompt the user for a path and filename to save a new JSON file to.
		\item If a game has been successfully saved, convey this information to the user via a dialog.
		\item If the player names have not been filled in, then do not save the game and inform the user that they have to fill in the names in the form of a dialog.
		\item If the game has an ID then save it by replacing the element of the games array with the same name by searching for the appropriate ID with a binary search.
	\end{enumerate}
	\item Allow a user to load a game and to continue to play it.
	\begin{enumerate}
		\item If the JSON file is not found then prompt the user to input the path to the game.
		\item Display the list of games in a table to allow the user to know which game to choose.
		\begin{enumerate}
			\item Information that must be shown in the table: ID, name of player 1 and 2, winner, moves made, last played.
			\item Using a quicksort algorithm, allow the user to sort the list of games based on parameters such as ID and the names of players.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}
\chapter{Documented Design}
\section{Overall System Design}
\subsection{Input}
The first type of input is selecting a piece on the board by clicking on a cell in the $ 8\times8 $ table that contains a piece corresponding to the player's colour. At this point processing occurs and moves that are legal are added as cells that can be clicked on the table. After this, if a cell is clicked that is not a player's piece then the last clicked piece is moved to that location. If a cell is clicked that is a player's piece the process described above is repeated.

The second type of input is the player name's that must be inputted if the game is to be saved. Both names can be edited via 2 separate GUI TextEdit components. 

The third type of input is to do with saving and loading games. A dialog asking for the location of a JSON file (or where to save it) allows the user to select the game file for the program. When the â€˜Load Button' game is pressed a dialog is shown where the user can choose a game to play from the file via a table.
\subsection{Processing}
The amount element of processing occurs when pieces are moved on the board. Once a user has used the GUI interface to declare what piece to move and to where it should be moved the main element of processing occurs. When this is done the program calculates all the possible legal moves for the opposing player's pieces. Then the GUI edits the table (which represents the chess board) such that the opponent can only select a cell in the table which represents a piece and its respective legal moves. In addition the program checks the game state and sees whether a player has won, or whether they are in check or if the game has ended in stalemate. If the game state has changed the user is informed through a dialog. 
\subsection{Storage}
All data that is required to load and save games is stored in public attributes of the Board class. When a game is saved these attributes are collated into a dictionary which is added to an array of games as a JSON file. When a game is loaded a new Board class I created where all the attributes of the loaded game are put into the class from the JSON dictionary.
\subsection{Output}
In terms of output there are three categories of output that the user will see. The first is of course the current board. The board has a visual representation of all the pieces on the correct parts of the board which is put into an 8x8 table with all cells of equal size. 

The second category is the state of the game. When the state of the game changes after a move, such as a player being in check or the game is over due to checkmate/stalemate, then the user is informed of this change by a dialog that appears. This dialog has a button to dismiss it to allow the players to continue to interact with the rest of the program, and forces users to acknowledge the change in game state.

The third category is the load dialog. The load dialog greets the user with list of games as rows on a table. The columns of the table give information about each game that is in the JSON file that the program reads from, such as the game ID, players, last played, moved made, winner etc. 
\section{Modular Structure}
\begin{figure}[H]
\centering
	\includegraphics[width=1.0\textwidth]{images/design-charts/top_level}
	\caption{Top level hierarchy chart.}
\end{figure}
\subsection{Second Level View}
\begin{figure}[H]
\centering
	\includegraphics[width=1.0\textwidth]{images/design-charts/gameplay_level}
	\caption{Second level hierarchy chart.}
\end{figure}
\begin{figure}[H]
\centering
	\includegraphics[width=1.0\textwidth]{images/design-charts/filehandling_level}
	\caption{Second level hierarchy chart.}
\end{figure}
\section{Code Design}
\subsection{Class Diagrams}
\begin{figure}[H]
\centering
	\includegraphics[width=1.0\textwidth]{images/class-diagrams/pieces}
	\caption{Class diagram for Piece and its subclasses.}
\end{figure}
\begin{figure}[H]
\centering
	\includegraphics[width=1.0\textwidth]{images/class-diagrams/board}
	\caption{Class diagram for the controllers and model of the program.}
\end{figure}
\subsection{File and Code Structure}
As the program is in the form of a Graphical User Interface (GUI) I thought it would be appropriate to design my code around the Model-View-Controller (MVC) framework. The view of the MVC architecture is the definition of the GUI. The model is the logic of the game board and the controller is what accepts inputs and interactions with the view, which converts them to commands to the model. The results of the model processing this data is then given back to the view by the controller. The .ui file type is the file that the Qt framework generates after editing of a GUI occurs in the Qt Designer application. These are then converted to .py by a command line utility pyside-uic. I then collated these files and put them into the views.py file.
\begin{figure}[H]
	\dirtree{%
	.1 /.
	.2 src.
	.3 ui\DTcomment{Contains all the UI files }.
	.4 chessboard.ui.
	.4 loadgame.ui.
	.4 mainwindow.ui.
	.4 promotion.ui.
	.3 algorithms.py\DTcomment{Binary search and quicksort.}.
	.3 board.py\DTcomment{Contains Board class: model for the controller.}.
	.3 Chess.py\DTcomment{Starts the program when run.}.
	.3 controllers.py\DTcomment{Contains all the controllers.}.
	.3 pieces.py\DTcomment{Contains Piece class and its subclasses, used by Board class.}.
	.3 views.py\DTcomment{Contains all the views: these are generated from the .ui files.}.
	.3 resources{\_}rc.py\DTcomment{Contains image data.}.
	.3 requirements.txt\DTcomment{Contains list of all python packages that the program requires to run.}.
	}
	\caption{Code structure of the program.}
\end{figure}
\subsection{Required Software}
For this program to run via running the Chess.py file it is required that Python 3 up until 3.4 is installed on the computer that the program will be run from, anything higher is not supported. This is because the program relies on PySide being installed and it does not support versions newer than 3.4. 
\subsection{Code Documentation}
In this section the comments to all the classes and functions in the program are shown. Views.py is not commented as it is simply a compilation of .ui files that have been compiled to Python classes and Chess.py is also not commented as it is simply boilerplate code to get the GUI to run. Similarly, resources{\_}qrc.py just contains image data of the chess pieces.
\subsubsection{algorithms.py}
\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize]{python}
def quick_sort(array, low, high):
	"""Sorts a list recursively.

	Args:
		array (list): the list to be sorted.
		low (int): index of lowest item to be sorted.
		high (int): index of highest item to be sorted.
	"""
	def partition(array, low, high):
	"""Partitions array using a pivot value.
	
	Args:
		array (list): the list to be sorted.
		low (int): index of lowest item to be sorted.
		high (int): index of highest item to be sorted.
	
	Returns:
		The value of the pivot.
	"""

def binary_search(search_term, array):
	"""Searches for an item in an already sorted list.

	Args:
		search_term (str): term to be searched for in the list.
		array (list): list to be searched.
	
	Returns:
		True if found, False otherwise.
	"""
\end{minted}
\subsubsection{board.py}
\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize]{python}
class Board(object):
    """Class which manages the pieces on the board.

	This is the model for the ChessBoardController class.
	The primary function of this class is to allow the controller to determine
	the legal moves a given piece can make and to move pieces on the board, whilst
	performing checks of the game state after every move.
	
	Attributes:
		id (int): the unique identifier for a particular game.
		last_played (str): The date at which the game was last saved.
		turn (str): The colour of the current player's turn.
		move_num (int): how many moves have been made in the game.
		winner (str): The name of the winner.
		colour_in_check (str): if a player is in check, their colour is held in this variable.
		is_stalemate (bool): shows if game is in stalemate or not.
		game_over (bool): shows if game is over or not.
		must_promote (bool): true if a player must promote their pawn, false otherwise.
		enpassant_possible (dict): shows if black and white can complete an en passant move.
		enpassant_move (dict): stores the en passant move for both colours if they exist.
		player_one (str): stores the name of the first player (white).
		player_two (str): stores the name of the second player (black).
		board (list): an 8*8 2D list which maps to pieces on the board.
	"""
	
	def __init__(self, game=None):
		"""Loads a game if given one, otherwise intialises a new game.
	
		Args:
			game (dict): contains all data needed to load a game into a Board object.
		"""
		
    def new_board(self):
		"""Creates a new board."""
		
	def preliminary_move_piece(self, chess_board, old_coords, new_coords):
		""""Will move a piece temporarily. e.g. used to see if piece puts itself in check.
	
		Args:
			chess_board (list): the board to be used to move the piece.
			old_coords (list): coordinates of the piece to be moved.
			new_coords (list): coordinates of where the piece will be moved to.
		
		Returns:
			list: returns a chess board with the piece moved.
		"""
		
    def preliminary_enpassant(self, chess_board, old_coords, new_coords, removed_coords):
		"""Will perform enpassant temporarily e.g. used to see if piece puts itself in check.

		Args:
			chess_board (list): the board to be used to move the piece.
			old_coords (list): coordinates of the piece to be moved.
			new_coords (list): coordinates of where the piece will be moved to.
			removed_coords (list): coordinates of the piece to be taken.
		
		Returns:
			list: returns a chess board with the piece moved.
		"""

    def permanently_move_piece(self, chess_board, old_coords, new_coords):
		"""
		Moves a piece on the board permanently.
		It will also check for change in game state (checkmate, check, stalemate).
		
		Args:
			chess_board (list): the board to be used to move the piece.
			old_coords (list): coordinates of the piece to be moved.
			new_coords (list): coordinates of where the piece will be moved to.
		
		Returns:
			list: returns a chess board with the piece moved.
		"""
	
	def permanently_promote_piece(self, type, coords):
		"""Promotes a pawn to a piece of a certain type.
	
		Args:
			type (str): Name of the type of piece to promote to.
			coords (list): coordinates of the pawn to be promoted.
		"""

	def check_game_state(self):
		"""Completes a check of the state of the game."""
		
 	def get_king_coords(self, colour, board):
		"""Finds the coords of the king depending on its colour.
		
		Args:
			colour (str): color of the king to find.
			board (list): the board to find the kind from.
		
		Returns:
			list: coordinates of the king in the form [x,y] (0-based).
		"""
		
 	def calculate_legal_moves(self, piece):
		"""Gets all the legal moves of a piece and returns them.
	
		Args:
			piece (Piece): The piece to calculate the legal moves for.
	
		Returns:
			list: A list of all the legal moves a piece can make.
		"""
	
 	def get_attacking_moves(self, piece, board):
		"""
		Get all the attacking moves of a piece and return them.
		The difference between this function and get_legal_moves() is that
		this shows you what pieces can force a check while the other functions
		tells you whether the piece can move there.
		
		Args:
			piece (Piece): The piece to calculate the legal moves for.
			board (board): board used to determine attacking moves.
		
		Returns:
			list: A list of all attacking moves a piece can make.
		"""
	
 	def calculate_is_checkmate(self, colour, board):
		"""Finds out if a player is in checkmate.
	
		Args:
			colour (str): Colour that we are checking for if they are in checkmate.
			board (list): the board of the game being played.
		
		Returns:
			bool: True if the game is in a state of checkmate, False otherwise.
		"""
	
 	def calculate_is_stalemate(self, board):
		"""Finds out if a game is in stalemate.
	
		Args:
			board (list): the board of the game being played.
	
		Returns:
			bool: True if the game is in a state of stalemate, False otherwise.
		"""
	
 	def is_in_check(self, colour, possible_board):
		"""Checks if the king of the corresponding colour is in check.
	
		Args:
			colour (str): colour that we are checking if they are in check.
			possible_board (list): the board of the game being played.
	
		Returns:
			bool: True if the player is in check, False otherwise.
		"""
	
 	def get_castling_moves(self, king, original_board):
		"""Finds castling moves, if they exist, for a given king.
	
		Args:
			king (King): the king that we are finding castling moves for.
			original_board (list): the board of the game being played.
		"""
	
 	def can_enpassant(self, pawn, possible_board):
		"""Checks if en passant is possible, and assigns the en passant move if so.
	
		Args:
			pawn (Pawn): the pawn that we are determining if it can perform en passant.
			possible_board (list): the board of the game being played.
	
		Raises:
			IndexError: raised when index is -1 or 8 as these indices do not exist in possible_board.
		"""
\end{minted}
\subsubsection{controllers.py}
\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize]{python}
class MainWindowController(QtGui.QMainWindow, views.MainWindow):
	"""Controller for the main window of the application"""


class ChessBoardController(QtGui.QWidget, views.ChessBoard):
	"""Controller for the chess board.
	Attributes pertaining to the views.ChessBoard class are not listed here as there are too many
	and they merely refer to Qt GUI Objects.

	Attributes:
		board (Board): instance of the Board class which serves as the model for the controller.
		settings (QSettings): a class used to store settings (namely file path) on the host computer.
		from_cell (list): stores the coordinates of the cell that was chosen to move from.
	"""
	
	def __init__(self):
		"""Initialises necessary variables, connects click events to methods and presents a new game to the user."""
		
	def table_clicked(self):
		"""Handler for when table is clicked.
	
		When a piece has been selected to move then its legal moves are calculated.
		These moves are then made clickable and highlighted yellow.
		If a user selects any of the highlighted colours then the piece is transferred to that position
		and a check of the game state occurs where any changes are shown in a msg box.
		Promotions, if necessary, are called in this method.
		"""
		
 	def output_board(self, legal_moves=[]):
		"""Output the board onto the GUI
	
		Uses the Board.board (2D list) to help populate the QTableWidget table.
		All pieces of the moving player are made clickable on the table.
		In addition, if there are legal moves specified they are all made clickable.

		Args:
			legal_moves (list): list of the legal moves a piece can make.
		"""
	
 	def new_game(self):
		"""Creates a new game with initial board setup."""
	
 	def load_game(self):
		"""Loads a game from a JSON file. If there is no JSON file the user is prompted for one.
	
		Raises:
			IOError: raised when there is an error loading a file.
			FileNotFoundError: raised when a file is not found.
			TypeError: raised when there is an error loading a file.
			KeyError: raised when there is corruption in the JSON file.
		"""
	
 	def save_game(self):
		"""Saves a currently played game, either in an existing JSON file or a new one.
	
		Raises:
			IOError: raised when there is an error loading a file.
			FileNotFoundError: raised when a file is not found.
		"""
		
 	def get_json_file(self):
		"""Gets the location of the JSON file from the user"""
	
 	def get_promotion_piece(self):
		"""Gets the piece that needs to be promoted"""
	
 	def show_message(self, msg):
		"""If there are errors, they are shown in a message box.
	
		Args:
			msg (str): message for the user to be shown.
		"""
		

class LoadDialogController(QtGui.QDialog, views.LoadDialog):
	"""Controller for the load dialog

	When 'Load Game' is pressed the user is shown this dialog if a JSON file is found and has been loaded.
	The user is shown a table where they can sort the games and can also choose which game to load.

	Attributes:
		chosen_game_id (int): id of the game that was chosen
		data (dict): List of games.
	"""
	
 	def __init__(self, data):
		"""Necessary variables are initialised and table is shown to the user."""
	
 	def output_table(self):
		"""List of games is shown to the user with this method."""
	
 	def sort(self):
		"""Sorts the list of games"""
	
 	def get_game(self):
		"""When game is chosen the ID is then found."""
\end{minted}
\subsubsection{pieces.py}
\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize]{python}
class Piece(object):
	"""Base class for all chess pieces

	Attributes:
		position (list): coordinates on the board in the form [x, y]
		colour (str): Colour of the piece, either "White" or "Black"
	"""
	
 	def __init__(self, position, colour):
		"""This constructor initialises the class variables and also calculates all possible moves for the piece."""
		
		@position.setter
		def position(self, value):
			""" This setter calculates the new possible moves once the position has changed.
		
			Args:
				value (list): coordinates on the board in the form [x, y]
			"""
	
 	def calculate_possible_moves(self):
		"""Shows us the coords it can go to assuming that there are no other pieces on the board
	
		Raises:
			NotImplementedError: Method not overridden in subclass.
		"""
		

class Rook(Piece):
	"""Class for a Rook

	Attributes:
		position (list): coordinates on the board in the form [x, y]
		colour (str): colour of the piece, either "White" or "Black"
		img_path (str): path to the image of the piece
		has_moved (bool): Denotes whether the piece has moved before.
	"""

    def __init__(self, position, colour, has_moved=False):
	"""
	This constructor initialises the class variables and also calculates all possible moves for the piece.
	In addition the image path is added.
	"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a rook in a certain position."""
		

class Knight(Piece):
	"""Class for a Knight

	Attributes:
		position (list): coordinates on the board in the form [x, y]
		colour (str): colour of the piece, either "White" or "Black"
		img_path (str): path to the image of the piece
	"""

 	def __init__(self, position, colour):
		"""
		This constructor initialises the class variables and also calculates all possible moves for the piece.
		In addition the image path is added as an attribute self.img_path.
		"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a knight in a certain position."""
	

class Bishop(Piece):
	"""Class for a Bishop

	Attributes:
		position (list): coordinates on the board in the form [x, y]
	colour (str): colour of the piece, either "White" or "Black"
	img_path (str): path to the image of the piece
	"""
	
	def __init__(self, position, colour):
	"""
	This constructor initialises the class variables and also calculates all possible moves for the piece.
	In addition the image path is added as an attribute self.img_path.
	"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a bishop in a certain position."""
	

class Queen(Piece):
	"""Class for a Queen

	Attributes:
		position (list): coordinates on the board in the form [x, y]
		colour (str): colour of the piece, either "White" or "Black"
		img_path (str): path to the image of the piece
	"""

	def __init__(self, position, colour):
		"""
		This constructor initialises the class variables and also calculates all possible moves for the piece.
		In addition the image path is added as an attribute self.img_path.
		"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a queen in a certain position."""
		

class King(Piece):
	"""Class for a King

	Attributes:
		position (list): coordinates on the board in the form [x, y].
		colour (str): colour of the piece, either "White" or "Black".
		img_path (str): path to the image of the piece.
		has_moved (bool): denotes whether piece has moved or not.
		castling_moves (list): list of all castling moves possible.
	"""

	def __init__(self, position, colour, has_moved=False, castling_moves=[]):
		"""
		This constructor initialises the class variables and also calculates all possible moves for the piece.
		In addition the image path is added as an attribute self.img_path.
		"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a king in a certain position."""

	
class Pawn(Piece):
	"""Class for a Pawn

	Attributes:
		position (list): coordinates on the board in the form [x, y]
		colour (str): colour of the piece, either "White" or "Black"
		img_path (str): path to the image of the piece
		first_moved (int): denotes at what stage (move) in the game the the piece was first moved.
	"""

	def __init__(self, position, colour, first_moved=0):
		"""
		This constructor initialises the class variables and also calculates all possible moves for the piece.
		In addition the image path is added as an attribute self.img_path.
		"""
	
 	def calculate_possible_moves(self):
		"""Calculates all the possible moves for a pawn in a certain position."""
\end{minted}
\section{Input Validation}
\begin{table}[H]
\centering
	\resizebox{\textwidth}{!}{%
	\begin{tabular}{|p{0.25\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.25\textwidth}|}
		\hline
		\textbf{Field} & \textbf{Validation} & \textbf{Description} & \textbf{Error Message}\\ \hline
		Player names & Presence & Check for their presence & "Please fill in the player names"\\ \hline
		Path to JSON file & Valid & Checks that file exists at specified location & "File not found"\\ \hline
		Name of new JSON file & Presence/Valid & Must not contain special characters & "File not saved"\\ \hline
		Game to load & Presence & Make sure ID corresponds to existing game & Game not loaded\\ \hline
		Move to make & Move legality & Checks if a proposed move is valid & Illegal moves are not marked yellow and are not clickable on the table\\ \hline
	\end{tabular}}
	\caption{Table of information on input validation.}
\end{table}
\section{Algorithm Commentary}
In this section, algorithms used in the code base that are considered complex are fully explained.
\subsection{Binary Search}
\begin{figure}[h]
	\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize, linenos]{python}
		def binary_search(search_term, array):
		"""Searches for an item in an already sorted list.
	
		Args:
			search_term (str): term to be searched for in the list.
			array (list): list to be searched.
	
		Returns:
			True if found, False otherwise.
		"""
		half_array = int(len(array)/2)
		if search_term == array[half_array]:
			return True
		elif len(array) == 1:
			return False
		elif search_term > array[half_array]:
			return binary_search(search_term, array[half_array:])
		else:
			return binary_search(search_term, array[:half_array])
	\end{minted}
	\caption{Source code for the recursive binary search algorithm.}
\end{figure}

As can be noted, this algorithm is a recursive function, with recursive calls at lines 17 and 19. The function is given a sorted array and compares the middle value of the array to the search term. The base case is met when the search term is found (line 13) or if the length of the array to be searched is 1 \textbf{and} the search term is not found (line 15). If that is not the case then if the search term is larger than the middle value, then the left half of the array is passed into the same function. Otherwise the right half is passed into the same function. This carries on until the base case is met. When it is the value of \mintinline{python}/True/ or \mintinline{python}/False/ is passed up the call stack such that the first call of the function will return \mintinline{python}/True/ or \mintinline{python}/False/.
\subsection{Quicksort}
Below is the code for the recursive quicksort algorithm:
\begin{figure}[H]
	\begin{minted}[breaklines, breakanywhere, tabsize=4, baselinestretch=1.0, fontsize=\footnotesize, linenos]{python}
	def quick_sort(array, low, high):
		"""Sorts a list recursively.
	
		Args:
			array (list): the list to be sorted.
			low (int): index of lowest item to be sorted.
			high (int): index of highest item to be sorted.
		"""
		def partition(array, low, high):
			"""Partitions array using a pivot value.
	
			Args:
				array (list): the list to be sorted.
				low (int): index of lowest item to be sorted.
				high (int): index of highest item to be sorted.
	
			Returns:
				The value of the pivot.
			"""
			i = low + 1
			pivot = array[low]
			for j in range(low+1, high+1):
				if array[j] < pivot:
					array[j], array[i] = array[i], array[j]
					i += 1
				array[low], array[i-1] = array[i-1], array[low]
				return i - 1
				
		if low < high:
			pivot = partition(array, low, high)
			quick_sort(array, low, pivot-1)
			quick_sort(array, pivot+1, high)
	\end{minted}
	\caption{Source code for the recursive quicksort algorithm.}
\end{figure}
It can be noted that there is an inner function defined at line 9. Instead of defining it as another function I decided to use it as an inner function to avoid code repetition and because it has no use outside of the quicksort function. The function accepts an unsorted list, and the index of the lowest and highest element of the list to sort. The partition function is then called, where the pivot value is the first element in the list. The array is changed such that all elements smaller than the pivot are put before it, and all elements bigger are put after it. Then the quicksort function is called twice. Once for values below the pivot and for values after. Once the base case has been met for each recursive call, the list is sorted. It does not need to be returned as an array (list) in python is a mutable change and is thus changed in its scope.
\section{User Interface}
\begin{figure}[h!t]
	\begin{annotatedFigure}
		{\includegraphics[width=1.0\linewidth]{images/screenshots/gui-overview.PNG}}
		\annotatedFigureBox{0.0099,0.046}{0.9924,0.9422}{A}{0.0099,0.9422}%tl
		\annotatedFigureBox{0.6296,0.952}{1,0.996}{B}{0.6296,0.952}%bl
		\annotatedFigureBox{0.1223,0.0031}{0.2228,0.04}{C}{0.2228,0.04}%tr
		\annotatedFigureBox{0.4443,0.004}{0.5611,0.044}{D}{0.5611,0.044}%tr
		\annotatedFigureBox{0.7707,0.002}{0.8875,0.042}{E}{0.8875,0.042}%tr
	\end{annotatedFigure}
	\caption{UI of the main program.}
\end{figure}
\begin{enumerate}[label=(\Alph*)]
	\item This is an $ 8\times8 $ table where input is carried out by clicking a piece then clicking again to a place where the piece is desired to be moved to. Only pieces for the player that is currently moving can be clicked. When it is clicked all of its legal moves are made yellow, and its cells are made clickable. All the cells of illegal moves are made unclickable, which simplifies validations of moves proposed a user.
	\item This is where the name of the second player (black) is added. To the left is where the name of the first player can be added.
	\item Pressing this button starts a new game, with the board the same as in figure~\ref{initial-board}.
	\item Pressing this button results in a dialog being shown, where the user can choose which game to load. If the game file is not found then the user will be prompted to insert the file's path.
	\item Pressing this button saves the game or prompts the user for a path to save the file in.
\end{enumerate}
\end{document}          
